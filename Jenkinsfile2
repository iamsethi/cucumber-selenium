pipeline {
    agent any
    stages {
        stage('Pull Latest Image') {
            steps {
                sh 'docker pull iamsethi/cucumber-selenium-docker'
            }
        }
        stage('Run Test') {
            steps {
               script {
 					def parallelTests = [:]  // creates empty map
 					def label
                  	packageJson = readJSON file: ('tests.json')
					parallelTests = packageJson.scripts
					parallelTests.each{ k, v -> echo("${k}:${v}") }
								
					listOfTests = parallelTests.keySet()		
					for (int i = 0 ; i < listOfTests.size() ; i++) {
					label = listOfTests[i]
					}
					
                def stringsToEcho = ["docker run -e HUB_HOST=http://192.168.1.10:4444/wd/hub -e BROWSER=chrome  -e TAG=@regression -v ${WORKSPACE}/chrome:/usr/share/udemy/target iamsethi/cucumber-selenium-docker  org.junit.runner.JUnitCore com.amazon.runner.RunnerTest", "b", "c", "d"]

				def stepsForParallel =parallelTests.each{ k, v -> 
    			["echoing ${k}" : transformIntoStep(v)]
					}

			parallel stepsForParallel
                }
        }
        }
       
        }
    post{
    always
    {
   	archiveArtifacts artifacts: 'chrome/**', fingerprint: true
   	archiveArtifacts artifacts: 'firefox/**', fingerprint: true
    }
    
    }
    
    
}


// Take the string and echo it.
def transformIntoStep(inputString) {
    // We need to wrap what we return in a Groovy closure, or else it's invoked
    // when this method is called, not when we pass it to parallel.
    // To do this, you need to wrap the code below in { }, and either return
    // that explicitly, or use { -> } syntax.
    return {
        node {
            sh inputString
        }
    }
}



